<link rel="import" href="../../components/polymer/polymer.html">

<!--
`more-route` provides token based routing.

Currently, it only supports hash based routing. The hope is that it can be
expanded into path based routing in the future (by declaring mount points).

Example:

    <more-route route="forums/:forumId/:postId" params="{{params}}"></more-route>

This example would make `params.forumId` and `params.postId` available.

Params declared in the route are two-way bound: If you modify a param's value,
the location hash will be modified appropriately, and vice versa.
-->
<polymer-element name="more-route" attributes="route params">
  <script>
  (function() {
    var TOKEN_MATCHER = /:([^\/]+)/g;

    Polymer('more-route', {
      publish: {
        /**
         * A routing expression used to parse parameters from the window's URL.
         *
         * @attribute route
         * @type String
         *
         */
        route: '',

        /**
         * The exposed parameters that were read from the URL.
         *
         * @attribute params
         * @type Object
         */
        params: {value: {}}
      },

      attached: function() {
        this._doRead = this._read.bind(this);
        window.addEventListener('hashchange', this._doRead);
      },

      detached: function() {
        window.removeEventListener('hashchange', this._doRead);
      },

      routeChanged: function() {
        this._paramIndexes = [];
        var compiled = this.route.replace(TOKEN_MATCHER, function(match, token) {
          this._paramIndexes.push(token);
          return '([^\/]+)';
        }.bind(this));

        this._compiled = new RegExp('^' + compiled);
        this._registerObservers(this._paramIndexes);
        this._read();
      },

      _registerObservers: function(keys) {
        if (this._paramObserver) this._paramObserver.close();
        this._paramObserver = new CompoundObserver();
        keys.forEach(function(param) {
          this._paramObserver.addPath(this, 'params.' + param);
        }.bind(this));

        this._paramObserver.open(this._write.bind(this));
      },

      _read: function() {
        this.params = {}; // Always reset, even for errors.
        var path =  this._getPath();
        var match = path.match(this._compiled);
        if (!match) {
          console.warn('Path', path, 'does not match route', this.route);
          return;
        }

        for (var i = 1, part; part = match[i]; i++) {
          this.params[this._paramIndexes[i - 1]] = part;
        }
      },

      _write: function() {
        var newPath = this.route.replace(TOKEN_MATCHER, function(match, token) {
          return this.params[token];
        }.bind(this));
        if (this._getPath() === newPath) return;

        history.pushState({}, '', '#' + newPath);
      },

      _getPath: function() {
        // TODO(nevir): Support more than just the hash: mount points.
        return window.location.hash.substring(1);
      },
    });

    function splice(string, start, length, replacement) {
      return string.substr(0, start) + replacement + string.substr(start + length);
    }
  })();
  </script>
</polymer-element>
